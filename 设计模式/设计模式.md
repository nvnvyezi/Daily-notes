### 单例模式

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。

```js
const signle = (function(){
  //实例的引用
  let unique;
  //判断是否已经实例化过,保证只会实例化一次
  function getInstance(){
    if(unique === 'undefined'){
			unique = new Constructor();
    }
    return unique;
  }
  //创建实例的构造函数
  function Constructor(){}
  return {
    getInstance
  }
})()
```

#### 优点

- 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。
- 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
- 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。

#### 缺点

- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
- 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。

#### 适用性

- 系统只需要一个实例对象
- 客户调用类的单个实例只允许使用一个公共访问点。

### 简单工厂模式

又称为静态工厂方法模式，根据参数的不同选择实现不同的具体对象。而且。工厂方法封装了对象的创建过程。如果创建过程非常复杂（比如依赖于配置文件或用户输入），工厂方法就非常有用了

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  sayName() {
    console.log(`name: ${this.name}`);
  }
  static createName(type) {
    switch (type) {
      case "dog":
        return new Animal("spike");
      case "cat":
        return new Animal("tom");
      default:
        return new Animal("jerry");
    }
  }
}

const dog = Animal.createName("dog");
const cat = Animal.createName("cat");
dog.sayName();
cat.sayName();
```

#### 优点

- 工厂类集中了所有对象的创建，便于对象创建的统一管理
- 对象的使用者仅仅是使用产品，实现了单一职责
- 便于扩展，如果新增了一种业务，只需要增加相关的业务对象类和工厂类中的生产业务对象的方法，不需要修改其他的地方。

#### 缺点

- 不够灵活，增加新的产品必须修改工厂类的代码
- 产品很多时，会造成工厂很复杂
- 一旦不能正常工作，会影响所有的

#### 适用性

- 创建对象需要大量重复的代码。
- 创建对象需要访问某些信息，而这些信息不应该包含在复合类中。
- 创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。

### 工厂方法模式

工厂不再负责所有产品的创建，而是将产品的创建过程交给专门的工厂子类去完成

```js
function Animal(name) {
  this.name = name;
}
Animal.prototype.sayName = function() {
  throw new Error("父类不提供实现");
};

function Dog(name) {
  Animal.call(name);
}
Dog.prototype = new Animal();
Dog.prototype.sayName = function() {
  console.log(`dog: ${this.name}`);
};

function Cat(name) {
  Animal.call(this, name);
}
Cat.prototype = new Animal();
Cat.prototype.sayName = function() {
  console.log(`cat: ${this.name}`);
};

const jerry = new Dog("jerry");
const tom = new Cat("tom");

jerry.sayName();
tom.sayName();

```

#### 优点

- 客服简单工厂模式的缺点
- 每个工厂类只完成单一任务
- 不使用静态工厂方法，可以形成基于继承的等级结构。

#### 缺点

- 不易于维护，假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。
- 当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦

#### 适用性

- 当一个类不知道它所需要的对象的类时
  在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；
- 当一个类希望通过其子类来指定创建对象时
  在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

### 抽象工厂模式

```js
function Animal(type, child) {
  if (typeof Animal[type] === "function") {
    function Fn() {}
    Fn.prototype = new Animal[type]();
    child.constructor = child;
    child.prototype = new Fn();
  } else {
    throw new Error("不存在类");
  }
}

Animal.dog = function() {};
Animal.dog.prototype.sayName = function() {
  console.log(`dog`);
};

const child = function() {};
Animal("dog", child);
const tom = new child();

tom.sayName();

```

#### 优点

- 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。
- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。

#### 缺点

- 抽象工厂模式在于难于应付“新对象”的需求变动。难以支持新种类的产品。难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂几乎确定了可以被创建的产品集合，支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。 

#### 适用性

- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
- 系统中有多于一个的产品族，而每次只使用其中某一产品族。
- 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
- 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

### 模块模式

模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用

```js
const singleModle = (function(){
  //私有变量
  const num = 1;
  function method (){};
  function method (){};
  //返回可供访问的属性
  return {
    method
  }
})();
```

#### 适用性

如果我们必须创建一个对象并以某些数据进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么我们这个时候就可以使用模块模式了。

### 代理模式

一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。

```js
function girl(name) {
  this.name = name;
}

function boy(girl) {
  this.girl = girl;
}

boy.prototype.send = function() {
  console.log(`送给${this.girl.name}`);
};

function tom() {
  this.boy = new boy(new girl("jerry"));
}

tom.prototype.send = function() {
  this.boy.send();
};

const t = new tom();
t.send();

```

#### 优点

- 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。
- 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
- 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。
- 保护代理可以控制对真实对象的使用权限。

#### 缺点

- 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。
- 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。

#### 适用性

- **使用虚拟代理实现图片的预加载**
- **虚拟代理合并http请求**
- **缓存代理**

### 观察者模式（发布订阅模式）

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展

```js
class PubSub {
  constructor(){
    this.subscribe = [];
  }
  sub (fn) {
    this.subscribe.push(fn);
  }
  pub (...rest) {
    for(let i = 0; i < this.subscribe.length; i++){
      this.subscribe[i].call(this, ...rest);
    }
  }
}
```

#### 优点

- 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。
- 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变

#### 缺点

- 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

#### 适用性

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

### 中介模式

[中介模式，代理模式，外观模式](https://blog.csdn.net/mengmei16/article/details/43981791)

**外观模式PK中介者模式：**

1.外观模式是结构型模式，中介者模式是行为型模式。
2.外观模式是对子系统提供统一的接口，中介者模式是用一个中介对象来封装一系列同事对象的交互行为。
3.外观模式协议是单向，中介者模式协议是双向。
4.外观模式所有的请求处理都委托给子系统完成，而中介者模式则由中心协调同事类和中心本身共同完成业务。

**外观模式PK代理模式：**

1.代理模式中的代理角色和真实角色都继承于同一类。而外观模式是多个类的集合。

2.代理角色与真实角色接口相同，功能一致，代理角色实现的是真实角色的功能。外观者模式的子系统功能不同，根据用户不同需要与外观类统一配置。

**代理模式PK中介者模式：**

1.代理模式是一对一，一个代理只能代表一个对象。中介者模式则是多对多，中介者的功能多样，客户也可以多个。

2.只能代理一方。如果PB是A的代理，那么C可以通过PB访问A，但是A不能通过PB访问B。对于中介者模式而言，A可以通过中介访问B，B也可以通过中介访问A。

### 装饰模式

装饰者模式，通过一个装饰类对现有动态添加行为，以及对原有行为进行装饰。

#### 优点

- 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
- 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。
- 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
- 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”

#### 缺点

- 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。
- 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

#### 适用性

- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。
- 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.

#### 策略模式

定义一系列算法，将每一个算法封装起来，并让它们可以相互替换

#### 优点

- 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。
- 策略模式提供了管理相关的算法族的办法。
- 策略模式提供了可以替换继承关系的办法。
- 使用策略模式可以避免使用多重条件转移语句。

#### 缺点

- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
- 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。

#### 适用性

- 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
- 一个系统需要动态地在几种算法中选择一种。
- 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。
- 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。

### 参考

[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)