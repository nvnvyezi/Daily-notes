[原文地址1](https://blog.csdn.net/prstaxy/article/details/68940360)

### CSRF(跨站点请求伪造)

`(Cross—Site Request Forgery)`

> 攻击者通过一些技术手段欺骗用户的浏览器去访问一些用户曾经认证过的网站并进行一些操作（发邮件，盗取信息，转账，购买商品等），这借助于浏览器的漏洞，简单的身份验证只能保证是同一个浏览器发出的请求，但是不能判断是谁在操作这个浏览器。

#### 流程

用户正常登录受信任网站A，并在本地生成A网站的一些身份认证信息。随后在没登出A的情况下，访问危险网站B。

#### 例子

假如一家银行用以运行转账操作的URL地址如下：

```http
http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName
```

那么，一个恶意攻击者可以在另一个网站上放置如下代码： 

```html
<img src="<http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman>">
```

如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。

#### 条件

- 不能保证用户登录了一个网站后，不再打开一个tab页面并访问另外的网站。
- 不能保证关闭浏览器了后，本地的Cookie立刻过期，即上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了......）
- 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。

### 防御

#### `Referer`

HTTP头中的Referer字段标明了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。

#### 使用验证码

关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。

#### 添加token验证

CSRF 攻击之所以能够成功，是因为用户所有验证信息都是存在于cookie中，攻击者可以完全伪造用户的请求。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。

#### header中自定义属性