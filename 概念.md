### **从输入一个url到浏览器页面展示都经历了哪些过程？ Dns查询、三次握手、http请求**



1、首先，在浏览器地址栏中输入url

2、浏览器先查看**浏览器缓存**-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。

3、在发送http请求前，需要**域名解析**(DNS解析)，解析获取相应的IP地址。

4、浏览器向服务器发起**tcp连接**，与浏览器建立**tcp三次握手**。

5、握手成功后，浏览器向服务器发送**http请求，请求数据包**。

6、**服务器处理收到的请**求，将数据返回至浏览器

7、**浏览器收到HTTP响应**

8、读取页面内容，**浏览器渲染，**解析html源码

9、生成Dom树、解析css样式、js交互

10、客户端和服务器交互

11、ajax查询

 

其中，步骤2的具体过程是：

- **浏览器缓存**：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
- **操作系统缓存：**如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；
- **路由器缓存**：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
- **ISP缓存：**若上述均失败，继续向ISP搜索。

先查看一下 TCP 头部的信息，如下图：

只介绍几个这里要用到的。序列号、确认号，标识：SYN，ACK，FIN。

- 序列号（sequence number）

  TCP 是面向字节流的，是 TCP 收发两端发送数据时所需，表示当然 TCP 段的第一个数据字节在整个数据流中的位置。也可以表示当前发送了多少数据。当前 seq - INS（初始 seq）

- 确认号（acknowledgement number）

  发送端发送 TCP 数据包到另一端后，接收端通过确认号来通知发送端接收成功了多少数据。即表示发送端成功发送了多少数据。后面简称为 ackn。

- SYN

  同步标识，通常用来建立连接。在“三次握手”的前两次出现。TCP 协议规定，SYN = 1 时，当前 TCP 段不能携带其他有效数据。

- ACK

  确认标识，接收端确认接收到数据。TCP 协议规定，只有 ACK = 1 时有效，即确认号信息才会包含在 TCP 段内，反正为 0。

- FIN

  结束标识。表示双方数据发送完成，跟 SYN 类似，属于行为标识。也是 FIN = 1 时，TCP 段内不能包含其他主体数据。

通过标识符就可以推断出处于 TCP 连接的所处位置。比如 SYN = 1，ACK = 0，一定就是握手第一阶段，SYN = 1，ACK = 1，就是握手第二阶段，只剩 ACK，就是第三阶段。同样 FIN 就是断开阶段。

### **2: new生成一个对象的过程： 核心就是return this啊**



使用关键字new创建新实例对象经过了以下几步：

1、创建一个新对象，如：var person = {};

2、新对象的_proto_属性指向构造函数的原型对象。

3、将构造函数的作用域赋值给新对象。（也所以this对象指向新对象）

4、执行构造函数内部的代码，将属性添加给person中的this对象。

5、返回新对象person。

### **什么是事件冒泡和事件捕获以及事件委托** 

一、事件捕获和冒泡是现代浏览器的执行事件的两个不同阶段

 二、事件委托是利用冒泡阶段的运行机制来实现的

#### 事件冒泡

> 从实际操作的元素（事件）向上级父元素一级一级执行下去，直到达到<html>

```
有些时候父元素和子元素都定义了click事件，但是不希望点击子元素的时候执行父元素的click事件（例如dialog弹窗的遮罩层如果是父元素，而dialog弹窗内容层是子元素，同时可以通过点击遮罩层来关闭弹窗，但是点击内容层不关闭弹窗），可以通过stopPropagation()在子元素上阻止冒泡。
```

#### 事件捕获（一般不会用到）

> 浏览器检查元素的最外层祖先<html>，是否在捕获阶段中注册了一个onclick事件处理程序，如果是，则运行它。
> 然后，它移动到<html>中的下一个元素(点击的元素的父元素)，并执行相同的操作，然后是下一个元素(点击的元素的父元素)，依此类推，直到到达实际点击的元素。

### 事件委托使用场景

> 如果你想要在大量子元素（包括动态添加的）中单击任何一个就可以运行一段代码，这个时候可以把事件监听器设置在父节点上。

![img](https://upload-images.jianshu.io/upload_images/22995-310ad4c72d7a1be0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/438)

### **GET,POST区别**

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。

**GET产生一个TCP数据包；POST产生两个TCP数据包。**

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别，上面的只是在使用上的区别。

> 什么是幂等性？幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。
>
>  因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。
>
>  

### 闭包

[闭包](https://segmentfault.com/a/1190000002452587)

