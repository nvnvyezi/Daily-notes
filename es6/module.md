### CommonJS

服务端的规范（node），同步加载

1. 定义模块: 一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性

2. 模块输出: 模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象

3. 加载模块: 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象

```js
// a.js
//私有变量
var test = 123;
//公有方法
function foobar () {
    this.foo = function () {
        // do someing ...
    }
    this.bar = function () {
        //do someing ...
    }
}
//exports对象上的方法和变量是公有的
var foobar = new foobar();
exports.foobar = foobar;
//require方法默认读取js文件，所以可以省略js后缀
var test = require('./boobar').foobar;
test.bar();
```

### AMD/RequireJS

#### AMD（Asynchronous Module Definition）

浏览器环境

1. 定义模块

2. ```typescript
   define(id?: String, dependencies?: String[], factory: Function|Object);
   ```

   - id 是模块名字，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。

   - dependencies指定了所要依赖的模块列表，是一个数组，可选的参数，每个依赖的模块的输出将作为参数一次传入 `factory` 中。如果没有指定 `dependencies`，那么它的默认值是 `["require", "exports", "module"]`。。
   - `factory` 包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。

2. 模块加载

```js
require([module], callback)
```

AMD模块化规范中使用全局或局部的require函数实现加载一个或多个模块，所有模块加载完成之后的回调函数。不同于commonjs的是两个参数

- [module]：是一个数组，里面的成员就是要加载的模块；
- callback：是模块加载完成之后的回调函数。

#### [RequireJS](https://javascript.ruanyifeng.com/tool/requirejs.html)

### CMD

CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是就近依赖，而AMD是前置依赖。

- 对于依赖的模块AMD是提前执行，CMD是延迟执行
- CMD推崇依赖就近，AMD推崇依赖前置。

```js
//AMD
define(['./a','./b'], function (a, b) {
    //依赖一开始就写好
    a.test();
    b.test();
});
 
//CMD
define(function (requie, exports, module) {
    //依赖可以就近书写
    var a = require('./a');
    a.test();
    ...
    //软依赖
    if (status) {
     
        var b = requie('./b');
        b.test();
    }
});
```

虽然 AMD也支持CMD写法，但依赖前置是官方文档的默认模块定义写法。

- AMD的API默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require，提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。

### UMD

兼容AMD和commonJS规范的同时，还兼容全局引用的方式

```js
(function (root, fn){
  if (typeof define === 'function' && define.amd) {
    //AMD
    define(['jquery'], fn);
  } else if(typeof exports === 'object') {
    // CommonJS
    module.exports = fn(require('jquery'));
  } else {
    // window
    root.fn1 = fn(root.jQuery)
  }
}(this, function($) {
  
}))
```

### AMD与CMD区别

**1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块** 
**2、CMD推崇就近依赖，只有在用到某个模块的时候再去require** 

AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同

同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行

CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的

因此AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因

### ES6 Module

编译时加载（静态加载），在编译时完成模块加载，效率更高，不能直接引用ES6模块本身，因为其不是对象

模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。

一个模块就是一个独立的文件

`export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

`import`命令输入的变量都是只读的

`import`命令具有提升效果，会提升到整个模块的头部，首先执行。

#### 好处

- 不再需要`UMD`模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
- 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者`navigator`对象的属性。
- 不再需要对象作为命名空间（比如`Math`对象），未来这些功能可以通过模块提供。

### ES6 模块与 CommonJS 模块的差异

#### CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

#### CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。

- 编译时加载: ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成

### 总结

| 区别项                                              | es模块化                                                     | commonJS                                           | AMD    |
| --------------------------------------------------- | ------------------------------------------------------------ | -------------------------------------------------- | ------ |
| 可用于服务端还是浏览器                              | 服务端和浏览器                                               | 服务端                                             | 浏览器 |
| 模块依赖关系何时确定(即：何时加载模块)              | 编译时                                                       | 运行时                                             | 运行时 |
| 设计思想                                            | 尽量的静态化                                                 |                                                    |        |
| 模块是不是对象                                      | 不是                                                         | 是                                                 |        |
| 是否整体加载模块(即加载的所有方法)                  | 否                                                           | 是                                                 |        |
| 是否是动态更新(即通过接口,可以取到模块内部实时的值) | 是。es module输出的是值的引用                                | 不是。commonJS模块输出的是值的拷贝，不存在动态更新 |        |
| 模块变量是否是只读的                                | 是。原因：ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。 |                                                    |        |

- commonJS模块就是对象，整体加载模块（即加载的所有方法）
- ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
- export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系
- export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时
- export命令和import命令可以出现在模块的任何位置，只要处于模块顶层就可以。 如果处于块级作用域内，就会报错，这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。
- import命令具有提升效果，会提升到整个模块的头部，首先执行。