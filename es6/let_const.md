### let

let允许声明一个作用域被限制在块级中的变量，语句或表达式。与var不同的是，var声明的变量只能是全局或者整个函数块的。

let和var声明的变量在其声明的块和子块中都是可用的，区别是var声明的变量作用域是整个封闭函数

let并不会像var一样在全局对象上创建一个属性

#### 暂存性死区与错误

1. let绑定不受变量提升的约束，在块中的变量初始化之前引用他将会引起引用错误。（var的情况不会引起错误，但是值是undefined）

2. ```js
   for (let expr1; expr2; expr3) statement
   ```

   expr2, expr3, 和 statement 都是包含在一个隐含域块中，其中也包含了 expr1.

#### todo

for循环中使用let时，设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

```js
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc abc abc
```

### const

创建一个常量，作用域可以是全局或本地声明的块，不会成为全局对象的属性 ，必须在声明变量的时候给其赋值。

一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。

创建一个值的只读引用，仅限变量标识符，在引用内容是对象的情况下，可以更改对象的内容

### 暂存死区

ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

```js
// 1
let x = x;
// 2
x = 2
let x;
// 3
switch(1) {
  case 0:
    let x;
    break;
  case 1:
    let x;
    break;
}
// 4
let x = 0;
for(let x; x < 5; x++) //x undefined
// 5
function main(){
    var x=1
    if(true){
        let x=x+2 
    }
}
```

let：提升声明

var：提升声明和初始化

function：提升声明，初始化，赋值

### var可以重复声明

js代码运行过程中会由引擎负责整个代码的编译以及运行，编译器负责词法分析，语法分析，代码生成等工作，作用域维护所有的标识符

执行var a = 2时，编辑器会对代码进行分析拆解，在遇到var a时，编辑器会查询是否存在a，不存在则令作用域声明一个a，存在的话省略var继续向下编译，随后碰到a = 2时，会先查看是否存在变量a，存在则将2赋值给a，不存在的话则先声明a随后将2赋值给a

