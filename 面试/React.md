这个项目是一个实验室成员自己使用的一个管理端，分为管理员管理端和个人管理端，我负责的就是个人管理端和登录模块，然后我详细说一下这个项目，在登录模块中布局的话使用flex实现一个两栏布局，具体实现就是右侧定宽，左侧用css3的calc计算宽度，像其他的两栏布局的话也可以采用float+margin的实现，或者position+margin实现。或者双inline-block，然后实现登录的话主要是表单登录和扫码登录，扫码登录的话他的一个主要流程就是后 	台向前端返回一个验证码，这个验证码就会携带一个id，手机在扫码以后就会拿到这个id，并且将这个id和自己的状态信息捆绑在一起发送给后台，这时候后台就知道了这个id对应的是谁的账号，然后将这个人的信息发给前端，前端在拿到这些信息之后就知道是谁在登录了。这样就实现一个扫码登录。然后因为扫码登录实现的话有两种方式，一种是前端不断地进行询问，另一种是服务器主动给我推送在验证码有效时间内是否有人登录，第一种方式的话可以采取短轮询和长轮询，短轮询的实现方式的话是前端每隔相等时间间隔就提交一次请求，并且不管有没有东西都进行一次回应，这样的话请求中有大半都是无用的请求，会严重浪费服务器资和带宽，而长轮询则是提交一次请求之后，在服务端保持住这个连接，等到有消息的时候在返回去，随后又开始发起一个新的请求重复相同的操作，他比短轮询好的地方就是如果一直没消息的话不会频繁的发送请求，但是消息是频繁变化的话和短轮询也差不多，并且他们都只适合小型应用，而如果服务端主动推送的话可以采取SSE或者websocket，SSE是服务器向客户端推送东西，他是一个单向的，实现的话是客户端发起一个请求后，服务端就始终保持着这个连接，他发送的不是一个数据包，而是一个数据流，并且在断开连接的时候会自动重连，SSE只适用于高级浏览器，在IE上因为
XHR不支持获取部分相应内容，所以不适用， websocket的话他是一个全双工通信的协议，在使用上会先借助http请求进行一次握手判断，他的主要用途是客户端和服务器进行双向通信，而验证码的使用上实际是服务器一直在推消息给客户端，因此使用sse会好一点，表单登录的话请求使用的是axios，因为使用jq的话，只使用一个ajax请求却需要将整个ajax库引进来，axios也是基于XHR封装 的一个，并且它支持promise的api和提供了并发请求的接口，还新添了请求拦截和相应拦截，原生支持防止csrf，以及从node创建http请求，而fetch的话脱离了xhr是es规范里新的实现方式，并且fetch是基于标准promsie实现的，也提供了更多的api，但是fetch只对网络请求报错，只要服务器返回东西，就会被resolved，fetch携带cookie需要手动设置，并且fetch没有取消请求的方法，也没有办法监测请求的进度，返回的信息必须进行json转才能拿到js对象，并且最大的问题是他的兼容性问题，并且他，存在一个跨域，最后的解决方案是借助webpack来进行跨域，而其他的跨域方式的话其实可以采用。

关系型数据库存在特定的表中，并且是在定义表的结构后在添加数据。所以关系型数据库容易理解，并且有丰富的完整性以及使用方便 ，这样灵活性就很低，

关系型数据库对事务一致性要求很高，

indexeddb允许对象的快速索引和搜索，因为是非关系型数据库，我们可以自己定义需要的对象和索引，是异步的

数据库事务的四个基本特征，原子性，一致性，隔离性，持久性，



之前用的是一个网上的库，但是需要的只是里面的部分功能，在刚开始实现的时候，是模拟拖拽那种，在一个大div里面一个小的div，然后根据小div的位置和大div的位置和大小成比例用canvas截取图片，接着用filereader生成一个base64的url，在最初的模型出来以后，因为拖拽框必须能让用户自己来定义大小，这样就只用一个div的话就不能满足，就吧里面的小的div改成每条边是一个div，并且每条边上的上中下三个点都是div，然后再这些div上在绑定监听函数，在用户拖拽的过程中，就必须加一些边界判断，以及开始是向左拉的话，在随后又开始向友拉，就必须将定位置的点换掉，并且判断是否超出界限，还有就是